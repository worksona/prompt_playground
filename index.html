<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worksona Playground</title>
    
    <!-- Core Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    
    <!-- Document Processing Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    
    <style>
        /* Color Variables */
        :root {
            --bold-orange: #FFA07A;
            --deep-blue: #5A7D9A;
            --light-orange: #FFDAB9;
            --light-blue: #B0E0E6;
            --neutral-gray: #A9A9A9;
            --white: #FFFFFF;
        }

        /* Base styles */
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--light-blue);
            overflow-x: hidden;
            position: relative;
        }

        #voronoi-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .container {
            padding: 2rem;
            display: flex;
            min-height: calc(100vh - 4rem);
            position: relative;
            z-index: 1;
        }

        /* Agency Details styles */
        .agency-details {
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.9);
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 1px 3px rgba(90, 125, 154, 0.2);
            backdrop-filter: blur(5px);
            border: 1px solid var(--light-orange);
        }

        .agency-name-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: none;
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.95);
            font-size: 1.25rem;
            font-weight: 500;
            height: 3rem;
        }

        .agency-description-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.95);
            min-height: 6rem;
        }

        /* Persona styles */
        .persona-tray {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
        }

        .persona-selector-container {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .persona-selector {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: var(--white);
        }

        .add-persona-btn {
            background: var(--deep-blue);
            color: var(--white);
            border: none;
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .persona-card {
            background: var(--light-orange);
            border-radius: 1rem;
            padding: 1rem;
            min-width: 300px;
            max-width: 400px;
            height: fit-content;
            flex-shrink: 0;
            border: 1px solid var(--bold-orange);
        }

        .persona-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .persona-emoji {
            font-size: 2rem;
        }

        .persona-title {
            font-weight: 500;
            color: var(--deep-blue);
        }

        .persona-name {
            font-weight: 500;
            color: var(--deep-blue);
        }

        .direction-selector {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: var(--white);
            margin-bottom: 1rem;
        }

        .persona-textarea {
            width: 100%;
            min-height: 150px;
            padding: '0.75rem 1rem';
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.95);
            margin-bottom: 1rem;
        }

        /* Image Upload styles */
        .image-upload-zone {
            border: 2px dashed var(--deep-blue);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.9);
            margin-bottom: 1rem;
        }

        .image-upload-zone:hover {
            border-color: var(--bold-orange);
            background: rgba(255, 255, 255, 0.95);
        }

        .image-preview {
            max-width: 100%;
            max-height: 300px;
            margin: 1rem 0;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Image Tray styles */
        .image-tray {
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.9);
        }

        .image-tray-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--deep-blue);
        }

        .image-preview-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .image-preview-item {
            position: relative;
            width: 100px;
            height: 100px;
            border-radius: 0.5rem;
            overflow: hidden;
            border: 2px solid transparent;
        }

        .image-preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-preview-item.selected {
            border-color: var(--bold-orange);
        }

        .image-preview-item .delete-button {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--deep-blue);
            font-weight: bold;
        }

        .image-prompt-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 1rem;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .image-preview-container {
            position: relative;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .image-preview-container img {
            max-width: 100%;
            display: block;
        }

        /* Login screen styles */
        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(176, 224, 230, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .login-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--deep-blue);
        }

        .password-input,
        .api-key-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.95);
        }

        /* Fixed left section */
        .fixed-section {
            width: 25%;
            min-width: 300px;
            max-width: 400px;
            flex-shrink: 0;
            padding: 1.5rem;
            border-right: 1px solid var(--deep-blue);
            background: rgba(255, 255, 255, 0.9);
            height: calc(100vh - 4rem - 76px);
            overflow-y: auto;
            position: fixed;
            left: 2rem;
            top: 2rem;
            box-shadow: 2px 0 4px rgba(90, 125, 154, 0.2);
            z-index: 100;
            backdrop-filter: blur(5px);
            border-radius: 1rem;
        }

        /* Content area */
        .content-area {
            flex: 1;
            margin-left: calc(25% + 3rem);
            min-width: 0;
            padding-bottom: 76px;
            padding-left: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        /* Horizontal scroll */
        .horizontal-scroll {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            padding: 1rem 0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: var(--deep-blue) transparent;
        }

        .horizontal-scroll::-webkit-scrollbar {
            height: 8px;
            border-radius: 4px;
        }

        .horizontal-scroll::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 4px;
        }

        .horizontal-scroll::-webkit-scrollbar-thumb {
            background-color: var(--deep-blue);
            border-radius: 4px;
        }

        /* Prompt card styles */
        .prompt-card {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1rem;
            box-shadow: 0 1px 3px rgba(90, 125, 154, 0.2);
            padding: 0.75rem;
            min-width: 300px;
            max-width: 400px;
            height: fit-content;
            flex-shrink: 0;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid var(--light-orange);
        }

        .prompt-card.image-mode {
            border-left: 4px solid var(--bold-orange);
        }

        .source-label {
            color: var(--deep-blue);
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .source-selector {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background-color: var(--white);
            outline: none;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .source-type-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 0.5rem;
        }

        .source-type-button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.5rem;
            background: var(--white);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .source-type-button.active {
            background: var(--deep-blue);
            color: var(--white);
        }

        .prompt-textarea {
            width: 100%;
            min-height: 150px;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.95);
            margin: 0;
            box-sizing: border-box;
            cursor: text;
            transition: border-color 0.2s ease;
        }

        .prompt-textarea:focus {
            border-color: var(--bold-orange);
            box-shadow: 0 0 0 2px rgba(255, 160, 122, 0.2);
        }

        .prompt-textarea::placeholder {
            color: var(--neutral-gray);
            opacity: 0.7;
        }

        .result-container {
            position: relative;
            width: 100%;
        }

        .result-textarea {
            width: 100%;
            min-height: 200px;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
            background: rgba(176, 224, 230, 0.1);
            margin: 0;
            box-sizing: border-box;
        }

        /* Button styles */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background-color: var(--deep-blue);
            color: var(--white);
            width: 100%;
        }

        .btn-success {
            background-color: var(--bold-orange);
            color: var(--white);
            width: 100%;
        }

        .btn-danger {
            background-color: var(--neutral-gray);
            color: var(--white);
            width: 100%;
        }

        .btn-agency {
            background-color: var(--deep-blue);
            color: var(--white);
        }

        /* Footer styles */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.9);
            padding: 1rem;
            box-shadow: 0 -1px 3px rgba(90, 125, 154, 0.2);
            display: flex;
            justify-content: center;
            gap: 1rem;
            z-index: 200;
            backdrop-filter: blur(5px);
            border-radius: 1rem 1rem 0 0;
            border-top: 1px solid var(--light-blue);
        }

        /* Loading spinner */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--white);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Utility styles */
        .hidden {
            display: none;
        }

        .error {
            background-color: rgba(255, 160, 122, 0.2);
            border-left: 4px solid var(--bold-orange);
            padding: 1rem;
            margin: 1rem 0;
            color: #b91c1c;
            border-radius: 0.75rem;
        }

        /* Copy button styles */
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--deep-blue);
            border-radius: 0.5rem;
            padding: 0.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .copy-button svg {
            width: 16px;
            height: 16px;
            stroke: var(--deep-blue);
        }

        .copy-button:hover {
            background: var(--deep-blue);
        }

        .copy-button:hover svg {
            stroke: var(--white);
        }

        .model-selector {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.95);
            outline: none;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <canvas id="voronoi-canvas"></canvas>
    <div id="root"></div>
    <script type="text/babel">
        // Constants
        const OPENAI_MODELS = [
            "gpt-4o",
            "gpt-3.5-turbo-1106",
            "gpt-3.5-turbo",
        ];

        const SUPPORTED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/gif'];
        const MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10MB

        const PERSONAS = [
  {
    "id": "chief_executive_officer",
    "name": "Chief Executive Officer",
    "emoji": "\ud83d\udc54",
    "description": "The CEO is the highest-ranking executive responsible for overseeing all aspects of the tech company's operations, strategy, and growth. This role involves setting the company's vision, leading the executive team, and ensuring the organization's success in a competitive and rapidly evolving industry. ### Key Responsibilities - Develop and implement high-quality business strategies aligned with short-term and long-term objectives[3] - ..."
  },
  {
    "id": "financial_asset_evaluator",
    "name": "Financial Asset Evaluator",
    "emoji": "\ud83d\udc54",
    "description": "The Financial Asset Evaluator is responsible for assessing the value of technology companies, their assets, and financial instruments. This role requires a deep understanding of the tech industry, financial markets, and valuation methodologies specific to technology firms. ### Key Responsibilities - Conduct comprehensive valuations of tech companies, startups, and their assets using various methodologies - Analyze financial..."
  },
  {
    "id": "financial_modeler",
    "name": "Financial Modeler",
    "emoji": "\ud83d\udc54",
    "description": "The Financial Modeler is responsible for developing and maintaining complex financial models to support strategic decision-making, valuation, and forecasting for tech companies. This role requires a deep understanding of the tech industry, financial analysis, and advanced modeling techniques. ### Key Responsibilities - Develop and maintain sophisticated financial models for tech companies, including revenue forecasts, cost structur..."
  },
  {
    "id": "asset_custodian",
    "name": "Asset Custodian",
    "emoji": "\ud83d\udc54",
    "description": "The Asset Custodian in the DeFi sector is responsible for the safekeeping, management, and oversight of digital assets within decentralized finance protocols and platforms. This role requires a deep understanding of blockchain technology, smart contracts, and DeFi ecosystems, as well as expertise in digital asset security and compliance. ### Key Responsibilities - Implement and maintain secure custody solutions for various digital as..."
  },
  {
    "id": "return_analyst",
    "name": "Return Analyst",
    "emoji": "\ud83d\udc54",
    "description": "The Return Analyst in the DeFi sector is responsible for analyzing and evaluating the performance of various decentralized finance protocols, strategies, and investments. This role requires a deep understanding of DeFi ecosystems, blockchain technology, and financial analysis techniques to provide valuable insights for decision-making and strategy development. ### Key Responsibilities - Analyze the performance and returns of various D..."
  },
  {
    "id": "tech_integrator",
    "name": "Tech Integrator",
    "emoji": "\ud83d\udc54",
    "description": "The Tech Integrator in the DeFi sector is responsible for integrating various decentralized finance protocols and technologies into cohesive systems. This role involves working with blockchain technology, smart contracts, and DeFi platforms to ensure seamless integration and functionality. The Tech Integrator plays a crucial role in enhancing the interoperability and efficiency of DeFi applications. ### Key Responsibilities - Design ..."
  },
  {
    "id": "trust_facilitator",
    "name": "Trust Facilitator",
    "emoji": "\ud83d\udc54",
    "description": "The Trust Facilitator in the DeFi sector is responsible for building and maintaining trust between the organization, its users, and other stakeholders. This role involves implementing trust-building strategies, ensuring compliance with data privacy regulations, and promoting transparency in DeFi operations. The Trust Facilitator plays a crucial role in enhancing the credibility and adoption of DeFi protocols and platforms. ### Key ..."
  },
  {
    "id": "social_integrator",
    "name": "Social Integrator",
    "emoji": "\ud83d\udc54",
    "description": "The Social Integrator in the DeFi sector is responsible for bridging the gap between decentralized finance protocols and their user communities. This role involves facilitating user engagement, building trust, and promoting social adoption of DeFi platforms. The Social Integrator plays a crucial role in enhancing user experience, community growth, and the overall success of DeFi projects. ### Key Responsibilities - Develop and impl..."
  },
  {
    "id": "diversification_specialist",
    "name": "Diversification Specialist",
    "emoji": "\ud83d\udc54",
    "description": "The Diversification Specialist in the DeFi sector is responsible for developing and implementing strategies to diversify investment portfolios and risk across various DeFi protocols and platforms. This role involves analyzing market trends, assessing risks, and creating innovative solutions to maximize returns while minimizing exposure in the volatile DeFi landscape. ### Key Responsibilities - Develop and implement diversi..."
  },
  {
    "id": "operations_strategist",
    "name": "Operations Strategist",
    "emoji": "\ud83d\udc54",
    "description": "The Operations Strategist in the DeFi sector is responsible for developing and implementing strategic operational plans to optimize the efficiency, scalability, and performance of decentralized finance platforms. This role involves analyzing current operations, identifying areas for improvement, and implementing innovative solutions to enhance the overall effectiveness of DeFi protocols and services. ### Key Responsibilities - ..."
  },
  {
    "id": "community_builder",
    "name": "Community Builder",
    "emoji": "\ud83d\udc54",
    "description": "The Community Builder in the DeFi sector is responsible for creating, nurturing, and growing a vibrant and engaged community around decentralized finance projects and platforms. This role involves developing and implementing strategies to increase user engagement, foster trust, and promote adoption of DeFi products and services. ### Key Responsibilities - Develop and execute comprehensive community engagement strategies for DeFi pr..."
  },
  {
    "id": "compliance_manager",
    "name": "Compliance Manager",
    "emoji": "\ud83d\udc54",
    "description": "The Compliance Manager in the DeFi sector is responsible for ensuring that decentralized finance protocols and platforms adhere to regulatory requirements and industry best practices. This role involves developing and implementing compliance programs, conducting risk assessments, and collaborating with various stakeholders to maintain a secure and compliant DeFi ecosystem. ### Key Responsibilities - Develop and implement comprehen..."
  },
  {
    "id": "executive",
    "name": "Executive",
    "emoji": "\ud83d\udc54",
    "description": "A senior business executive responsible for strategic decision-making and achieving high-level business impact. The Executive drives organizational goals, manages company performance, and collaborates with stakeholders to ensure sustainable growth. This role involves setting the strategic direction, fostering leadership across teams, and ensuring alignment with industry trends. Executives play a critical role in overseeing finances, human resources, and operations, while acting as ambassadors for the organization's mission."
  },
  {
    "id": "engineer",
    "name": "Engineer",
    "emoji": "\ud83d\udc68\u200d\ud83d\udcbb",
    "description": "A technical professional with expertise in designing, implementing, and maintaining complex systems and solutions. Engineers work across various disciplines such as software development, hardware design, and process optimization, ensuring high-quality results. They apply their knowledge to solve technical challenges, improve efficiency, and drive innovation. In addition, engineers collaborate with cross-functional teams to align technical implementations with business objectives."
  },
  {
    "id": "creative",
    "name": "Creative Director",
    "emoji": "\ud83c\udfa8",
    "description": "A visionary professional responsible for shaping the creative strategy, design, and storytelling of an organization. The Creative Director oversees the development of visual content, branding, and campaigns to resonate with audiences. They lead creative teams, ensuring the delivery of innovative and impactful work that aligns with brand values and market trends. This role combines artistic vision with leadership skills to produce compelling narratives across various platforms."
  },
  {
    "id": "analyst",
    "name": "Data Analyst",
    "emoji": "\ud83d\udcca",
    "description": "An analytical expert focused on deriving actionable insights from data to support business decision-making. Data Analysts collect, process, and analyze large datasets to identify trends, patterns, and opportunities. They create detailed reports, dashboards, and visualizations to communicate findings effectively to stakeholders. This role is essential in guiding strategic planning, optimizing operations, and measuring the success of business initiatives."
  },
  {
    "id": "marketer",
    "name": "Marketing Manager",
    "emoji": "\ud83d\udce2",
    "description": "A dynamic professional responsible for planning, executing, and analyzing marketing strategies to engage target audiences. The Marketing Manager develops campaigns, manages budgets, and tracks key performance metrics to drive brand awareness and sales. They collaborate with creative and sales teams to align messaging and ensure consistent brand representation. This role is pivotal in understanding customer needs, market trends, and competitive landscapes to deliver impactful marketing solutions."
  }
];

        // Voronoi Background Component
        const VoronoiBackground = () => {
            React.useEffect(() => {
                const canvas = document.getElementById('voronoi-canvas');
                const context = canvas.getContext('2d');
                const numPoints = 100;
                const points = [];
                let width = window.innerWidth;
                let height = window.innerHeight;
                let animationFrameId;

                class Point {
                    constructor() {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = (Math.random() - 0.5) * 2;
                    }

                    update() {
                        this.x += this.vx;
                        this.y += this.vy;

                        if (this.x < 0 || this.x > width) this.vx *= -1;
                        if (this.y < 0 || this.y > height) this.vy *= -1;
                    }
                }

                function resizeCanvas() {
                    width = window.innerWidth;
                    height = window.innerHeight;
                    canvas.width = width;
                    canvas.height = height;
                }

                function initPoints() {
                    points.length = 0;
                    for (let i = 0; i < numPoints; i++) {
                        points.push(new Point());
                    }
                }

                function drawVoronoi() {
                    context.clearRect(0, 0, width, height);

                    // Update points
                    points.forEach(point => point.update());

                    // Create Voronoi diagram
                    const delaunay = d3.Delaunay.from(points.map(p => [p.x, p.y]));
                    const voronoi = delaunay.voronoi([0, 0, width, height]);

                    // Draw cells
                    context.beginPath();
                    context.strokeStyle = "rgba(90, 125, 154, 0.2)";
                    voronoi.render(context);
                    context.stroke();
                }

                function animate() {
                    drawVoronoi();
                    animationFrameId = requestAnimationFrame(animate);
                }

                // Initialize
                resizeCanvas();
                initPoints();

                // Event listeners
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    initPoints();
                });

                // Start animation
                animate();

                // Cleanup
                return () => {
                    cancelAnimationFrame(animationFrameId);
                    window.removeEventListener('resize', resizeCanvas);
                };
            }, []);

            return null;
        };

        // File Processing Utility
        const FileProcessor = {
            async readPDFFile(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    let text = '';
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const content = await page.getTextContent();
                        const strings = content.items.map(item => item.str);
                        text += strings.join(' ') + '\n';
                    }
                    
                    return text.trim();
                } catch (error) {
                    console.error('PDF Processing Error:', error);
                    throw new Error(`Failed to process PDF file: ${error.message}`);
                }
            },

            async readDocFile(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const result = await mammoth.extractRawText({ arrayBuffer });
                    return result.value.trim();
                } catch (error) {
                    console.error('DOC Processing Error:', error);
                    throw new Error(`Failed to process DOC/DOCX file: ${error.message}`);
                }
            },

            async readTextFile(file) {
                try {
                    const text = await file.text();
                    return text.trim();
                } catch (error) {
                    console.error('Text File Processing Error:', error);
                    throw new Error(`Failed to read text file: ${error.message}`);
                }
            },

            async processImage(file) {
                if (!file || !SUPPORTED_IMAGE_TYPES.includes(file.type)) {
                    throw new Error('Unsupported image type');
                }

                if (file.size > MAX_IMAGE_SIZE) {
                    throw new Error('Image size too large (max 10MB)');
                }

                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Error reading image'));
                    reader.readAsDataURL(file);
                });
            },

            async processFile(file) {
                if (!file) throw new Error('No file provided');

                const fileType = file.type;
                if (SUPPORTED_IMAGE_TYPES.includes(fileType)) {
                    return await this.processImage(file);
                }

                const extension = file.name.toLowerCase().split('.').pop();
                switch (extension) {
                    case 'pdf':
                        return await this.readPDFFile(file);
                    case 'doc':
                    case 'docx':
                        return await this.readDocFile(file);
                    case 'txt':
                    case 'md':
                        return await this.readTextFile(file);
                    default:
                        throw new Error(`Unsupported file type: ${extension}`);
                }
            }
        };

        // React Components
        const CopyButton = ({ text }) => {
            const [copied, setCopied] = React.useState(false);
            
            const copyToClipboard = async () => {
                try {
                    await navigator.clipboard.writeText(text);
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                } catch (err) {
                    console.error('Failed to copy:', err);
                }
            };

            return (
                <button 
                    onClick={copyToClipboard} 
                    className="copy-button" 
                    title={copied ? "Copied!" : "Copy to clipboard"}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        {copied ? (
                            <path d="M20 6L9 17l-5-5"/>
                        ) : (
                            <>
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                            </>
                        )}
                    </svg>
                </button>
            );
        };

        const ProcessingIndicator = ({ isVisible }) => (
            <div className={`processing-file ${!isVisible ? 'hidden' : ''}`}>
                <h3>Processing File...</h3>
                <p>Please wait while we process your content</p>
            </div>
        );

        const LoginScreen = ({ onLogin }) => {
            const [password, setPassword] = React.useState('');
            const [apiKey, setApiKey] = React.useState('');
            const [error, setError] = React.useState('');

            const handleLogin = () => {
                if (password === 'wowsona' && apiKey) {
                    onLogin(apiKey);
                } else {
                    setError('Incorrect password or missing API key');
                }
            };

            return (
                <div className="login-screen">
                    <div className="login-box">
                        <h2 style={{ marginBottom: '1rem', color: 'var(--deep-blue)' }}>Login Required</h2>
                        <input
                            type="password"
                            placeholder="Enter password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            className="password-input"
                            onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
                        />
                        <input
                            type="text"
                            placeholder="Enter OpenAI API Key"
                            value={apiKey}
                            onChange={(e) => setApiKey(e.target.value)}
                            className="api-key-input"
                            onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
                        />
                        <button 
                            onClick={handleLogin}
                            className="btn btn-primary"
                        >
                            Login
                        </button>
                        {error && <div className="error">{error}</div>}
                    </div>
                </div>
            );
        };
        const PersonaCard = ({ persona, onUpdate, onDelete }) => {
            return (
                <div className="persona-card">
                    <div className="persona-header">
                        <span className="persona-emoji">{persona.emoji}</span>
                        <span className="persona-title">PERSONA CARD</span>
                        <input 
                            type="text" 
                            className="persona-name" 
                            value={persona.name} 
                            onChange={(e) => onUpdate(persona.cardId, { name: e.target.value })}
                            style={{ 
                                border: '1px solid var(--deep-blue)',
                                background: '#f0f8ff',
                                borderRadius: '0.75rem',
                                padding: '0.5rem',
                                fontFamily: 'inherit',
                                fontSize: 'inherit',
                                outline: 'none'
                            }}
                        />
                    </div>
                    
                    <select 
                        value={persona.direction}
                        onChange={(e) => onUpdate(persona.cardId, { direction: e.target.value })}
                        className="direction-selector"
                    >
                        <option value="from">AUTHOR</option>
                        <option value="to">AUDIENCE</option>
                    </select>
                    
                    <textarea
                        value={persona.description}
                        onChange={(e) => onUpdate(persona.cardId, { description: e.target.value })}
                        className="persona-textarea"
                        spellCheck="true"
                        rows="6"
                    />
                    
                    <button 
                        onClick={() => onDelete(persona.cardId)}
                        className="btn btn-danger"
                    >
                        Delete
                    </button>
                </div>
            );
        };

        const PersonaTray = ({ onAddPersona }) => {
            const [selectedPersona, setSelectedPersona] = React.useState('');

            const handleAddPersona = () => {
                if (selectedPersona) {
                    const persona = PERSONAS.find(p => p.id === selectedPersona);
                    onAddPersona({
                        ...persona,
                        cardId: Date.now(),
                        direction: 'from'
                    });
                    setSelectedPersona('');
                }
            };

            return (
                <div className="persona-tray" style={{ marginBottom: '1rem' }}>
                    <div className="persona-selector-container">
                        <select 
                            value={selectedPersona}
                            onChange={(e) => setSelectedPersona(e.target.value)}
                            className="persona-selector"
                        >
                            <option value="">Select Persona...</option>
                            {PERSONAS.map(persona => (
                                <option key={persona.id} value={persona.id}>
                                    {persona.emoji} {persona.name}
                                </option>
                            ))}
                        </select>
                        <button 
                            onClick={handleAddPersona}
                            className="add-persona-btn"
                            disabled={!selectedPersona}
                        >
                            +
                        </button>
                    </div>
                </div>
            );
        };

        const PromptCard = ({ prompt, sourceOptions, loading, onUpdate, onDelete, onRun, uploadedImages }) => {
            const isImageMode = prompt.sourceType === 'image';

            return (
                <div className={`prompt-card ${isImageMode ? 'image-mode' : ''}`}>
                    <div className="source-type-selector">
                        <button 
                            className={`source-type-button ${!isImageMode ? 'active' : ''}`}
                            onClick={() => onUpdate(prompt.id, { sourceType: 'text', selectedImage: null })}
                        >
                            Text
                        </button>
                        <button 
                            className={`source-type-button ${isImageMode ? 'active' : ''}`}
                            onClick={() => onUpdate(prompt.id, { sourceType: 'image' })}
                        >
                            Image
                        </button>
                    </div>

                    {isImageMode ? (
                        <select
                            value={prompt.selectedImage || ''}
                            onChange={(e) => onUpdate(prompt.id, { selectedImage: parseInt(e.target.value) })}
                            className="source-selector"
                        >
                            <option value="">Select an image...</option>
                            {uploadedImages.map(img => (
                                <option key={img.id} value={img.id}>
                                    {img.name || `Image ${img.id}`}
                                </option>
                            ))}
                        </select>
                    ) : (
                        <select 
                            value={prompt.source}
                            onChange={(e) => onUpdate(prompt.id, { source: e.target.value })}
                            className="source-selector"
                        >
                            <option value="SOURCE">SOURCE</option>
                            {sourceOptions.map(option => (
                                <option key={option.id} value={`RESULT${option.id}`}>
                                    RESULT{option.id}
                                </option>
                            ))}
                        </select>
                    )}
                    
                    <textarea
                        value={prompt.text}
                        onChange={(e) => onUpdate(prompt.id, { text: e.target.value })}
                        placeholder={isImageMode ? "Enter your image analysis prompt..." : "Enter your prompt..."}
                        className="prompt-textarea"
                        spellCheck="true"
                        autoComplete="off"
                        rows="6"
                    />
                    
                    <div className="result-label">RESULT{prompt.id}</div>
                    
                    <div className="result-container">
                        <textarea
                            value={prompt.result}
                            onChange={(e) => onUpdate(prompt.id, { result: e.target.value })}
                            placeholder="Results will appear here..."
                            className="result-textarea"
                            readOnly
                            rows="8"
                        />
                        <CopyButton text={prompt.result} />
                    </div>
                    
                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                        <button 
                            onClick={() => onRun(prompt.id)} 
                            className="btn btn-success"
                            disabled={loading || (isImageMode && !prompt.selectedImage)}
                        >
                            {loading ? (
                                <span className="loading-spinner" />
                            ) : (
                                isImageMode ? 'Analyze Image' : 'Run'
                            )}
                        </button>
                        <button 
                            onClick={() => onDelete(prompt.id)}
                            className="btn btn-danger"
                        >
                            Delete
                        </button>
                    </div>
                </div>
            );
        };

        // Main App Component
        function App() {
            const [isLoggedIn, setIsLoggedIn] = React.useState(false);
            const [apiKey, setApiKey] = React.useState('');
            const [model, setModel] = React.useState(OPENAI_MODELS[0]);
            const [sourceContent, setSourceContent] = React.useState('');
            const [uploadedImages, setUploadedImages] = React.useState([]);
            const [agencyName, setAgencyName] = React.useState('');
            const [agencyDescription, setAgencyDescription] = React.useState('');
            const [personaCards, setPersonaCards] = React.useState([]);
            const [prompts, setPrompts] = React.useState([{ 
                id: 1, 
                text: '', 
                result: '',
                source: 'SOURCE',
                sourceType: 'text',
                selectedImage: null
            }]);
            const [loading, setLoading] = React.useState({});
            const [error, setError] = React.useState('');
            const [isProcessingFile, setIsProcessingFile] = React.useState(false);

            // Check if user is logged in
            if (!isLoggedIn) {
                return (
                    <>
                        <VoronoiBackground />
                        <LoginScreen onLogin={(key) => { setApiKey(key); setIsLoggedIn(true); }} />
                    </>
                );
            }

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setIsProcessingFile(true);
                setError('');

                try {
                    const content = await FileProcessor.processFile(file);
                    
                    if (SUPPORTED_IMAGE_TYPES.includes(file.type)) {
                        const imageId = Date.now();
                        setUploadedImages(current => [...current, {
                            id: imageId,
                            url: content,
                            name: file.name
                        }]);
                    } else {
                        setSourceContent(content);
                    }
                } catch (error) {
                    setError('Error processing file: ' + error.message);
                } finally {
                    setIsProcessingFile(false);
                }
            };

            const deleteImage = (imageId) => {
                setUploadedImages(current => current.filter(img => img.id !== imageId));
                setPrompts(current => current.map(prompt => 
                    prompt.selectedImage === imageId 
                        ? {...prompt, selectedImage: null}
                        : prompt
                ));
            };

            const ImageTray = () => (
                <div className="image-tray">
                    <div className="image-tray-title">Uploaded Images</div>
                    <div className="image-preview-list">
                        {uploadedImages.map(image => (
                            <div key={image.id} className="image-preview-item">
                                <img src={image.url} alt={image.name} />
                                <button 
                                    className="delete-button"
                                    onClick={() => deleteImage(image.id)}
                                >
                                    Ã—
                                </button>
                            </div>
                        ))}
                    </div>
                </div>
            );

            const addPersonaCard = (persona) => {
                setPersonaCards([...personaCards, persona]);
            };

            const updatePersonaCard = (id, changes) => {
                setPersonaCards(personaCards.map(p => 
                    p.cardId === id ? {...p, ...changes} : p
                ));
            };

            const deletePersonaCard = (id) => {
                setPersonaCards(personaCards.filter(p => p.cardId !== id));
            };

            const addPrompt = () => {
                const newPrompt = {
                    id: Date.now(),
                    text: '',
                    result: '',
                    source: 'SOURCE',
                    sourceType: 'text',
                    selectedImage: null
                };
                setPrompts([...prompts, newPrompt]);
            };

            const deletePrompt = (id) => {
                setPrompts(prompts.filter(p => p.id !== id));
            };

            const updatePrompt = (id, changes) => {
                setPrompts(prompts.map(p => 
                    p.id === id ? {...p, ...changes} : p
                ));
            };

            const getPromptSource = (promptId) => {
                const prompt = prompts.find(p => p.id === promptId);
                if (!prompt || prompt.source === 'SOURCE') return sourceContent;
                
                const sourcePromptId = parseInt(prompt.source.replace('RESULT', ''));
                const sourcePrompt = prompts.find(p => p.id === sourcePromptId);
                return sourcePrompt ? sourcePrompt.result : '';
            };

            const getPersonaContext = () => {
                const fromPersonas = personaCards.filter(p => p.direction === 'from');
                const toPersonas = personaCards.filter(p => p.direction === 'to');
                
                let context = '';
                
                if (fromPersonas.length > 0) {
                    context += `\nRespond FROM the perspective of: ${fromPersonas.map(p => 
                        `${p.name} (${p.description})`).join(', ')}`;
                }
                
                if (toPersonas.length > 0) {
                    context += `\nTarget your response TO: ${toPersonas.map(p => 
                        `${p.name} (${p.description})`).join(', ')}`;
                }
                
                return context;
            };

            const runPrompt = async (id) => {
                setLoading(prev => ({ ...prev, [id]: true }));
                setError('');

                try {
                    const prompt = prompts.find(p => p.id === id);
                    let requestBody;

                    if (prompt.sourceType === 'image') {
                        const selectedImage = uploadedImages.find(img => img.id === prompt.selectedImage);
                        if (!selectedImage) throw new Error('No image selected');

                        requestBody = {
                            model: model,
                            messages: [
                                {
                                    role: "user",
                                    content: [
                                        {
                                            type: "text",
                                            text: `${getPersonaContext()}\n${prompt.text}`
                                        },
                                        {
                                            type: "image_url",
                                            image_url: {
                                                url: selectedImage.url
                                            }
                                        }
                                    ]
                                }
                            ],
                            max_tokens: 500
                        };
                    } else {
                        const sourceText = getPromptSource(id);
                        const personaContext = getPersonaContext();
                        requestBody = {
                            model: model,
                            messages: [
                                { 
                                    role: "system", 
                                    content: `Context:\n${sourceText}${personaContext}`
                                },
                                { 
                                    role: "user", 
                                    content: prompt.text 
                                }
                            ]
                        };
                    }

                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    const data = await response.json();
                    
                    if (data.error) {
                        if (data.error.code === 'model_not_found' || data.error.message.includes('deprecated')) {
                            throw new Error('This model has been deprecated. Please select a different model from the dropdown.');
                        }
                        throw new Error(data.error.message);
                    }

                    const result = data.choices[0].message.content;
                    updatePrompt(id, { result });

                } catch (err) {
                    setError(err.message || 'Error running prompt');
                } finally {
                    setLoading(prev => ({ ...prev, [id]: false }));
                }
            };

            const runAllPrompts = async () => {
                for (const prompt of prompts) {
                    await runPrompt(prompt.id);
                }
            };

            const exportAgency = async () => {
                try {
                    const exportData = {
                        agencyName,
                        agencyDescription,
                        sourceContent,
                        uploadedImages,
                        personaCards,
                        prompts: prompts.map(({ id, text, result, source, sourceType, selectedImage }) => ({
                            id,
                            text,
                            result,
                            source,
                            sourceType,
                            selectedImage
                        })),
                        settings: { model }
                    };
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                        type: 'application/json' 
                    });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `agency-export-${Date.now()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    setError('Error exporting agency: ' + error.message);
                }
            };

            const exportContent = () => {
                try {
                    const content = prompts.map(prompt => {
                        let promptContent = `PROMPT ${prompt.id}:\n${prompt.text}\n\n`;
                        if (prompt.sourceType === 'image') {
                            promptContent += `[Image Analysis]\n`;
                        }
                        promptContent += `RESULT ${prompt.id}:\n${prompt.result}\n\n---\n\n`;
                        return promptContent;
                    }).join('');
                    
                    const blob = new Blob([content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `agency-content-${Date.now()}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    setError('Error exporting content: ' + error.message);
                }
            };

            const loadAgency = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (!data.prompts || !data.settings) {
                            throw new Error('Invalid agency file structure');
                        }

                        setSourceContent(data.sourceContent || '');
                        setPrompts(data.prompts);
                        setModel(data.settings.model || OPENAI_MODELS[0]);
                        setAgencyName(data.agencyName || '');
                        setAgencyDescription(data.agencyDescription || '');
                        setUploadedImages(data.uploadedImages || []);
                        setPersonaCards(data.personaCards || []);
                    } catch (error) {
                        setError('Error loading agency: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };

            return (
                <>
                    <VoronoiBackground />
                    <div className="container">
                        <ProcessingIndicator isVisible={isProcessingFile} />
                        
                        <div className="fixed-section">
                            <input
                                type="file"
                                id="fileInput"
                                className="hidden"
                                accept=".pdf,.doc,.docx,.txt,.md,image/*"
                                onChange={handleFileUpload}
                            />
                            <button 
                                onClick={() => document.getElementById('fileInput').click()}
                                className="btn btn-primary"
                                style={{ marginBottom: '1rem' }}
                            >
                                Upload File or Image
                            </button>

                            <textarea
                                value={sourceContent}
                                onChange={(e) => setSourceContent(e.target.value)}
                                placeholder="Enter or upload source content..."
                                style={{ 
                                    display: 'block',
                                    width: '80%',
                                    minHeight: '200px',
                                    margin: '1rem auto',
                                    padding: '0.75rem',
                                    borderRadius: '0.75rem',
                                    border: '1px solid var(--deep-blue)',
                                    resize: 'vertical'
                                }}
                            />

                            <ImageTray />
                            <PersonaTray onAddPersona={addPersonaCard} />

                            <div className="model-selector-wrapper">
                                <select 
                                    value={model}
                                    onChange={(e) => setModel(e.target.value)}
                                    className="model-selector"
                                >
                                    {OPENAI_MODELS.map(model => (
                                        <option key={model} value={model}>{model}</option>
                                    ))}
                                </select>
                            </div>

                            {error && <div className="error">{error}</div>}
                        </div>

                        <div className="content-area">
                            <div className="agency-details">
                                <textarea
                                    value={agencyName}
                                    onChange={(e) => setAgencyName(e.target.value)}
                                    placeholder="Enter Agency Name..."
                                    className="agency-name-textarea"
                                    style={{ paddingRight: '1rem' }}
                                />
                                <textarea
                                    value={agencyDescription}
                                    onChange={(e) => setAgencyDescription(e.target.value)}
                                    placeholder="Enter Agency Description..."
                                    className="agency-description-textarea"
                                    style={{ paddingRight: '1rem' }}
                                />
                            </div>
                            
                            <div className="horizontal-scroll">
                                {personaCards.map(persona => (
                                    <PersonaCard
                                        key={persona.cardId}
                                        persona={persona}
                                        onUpdate={updatePersonaCard}
                                        onDelete={deletePersonaCard}
                                    />
                                ))}
                                {prompts.map(prompt => (
                                    <PromptCard
                                        key={prompt.id}
                                        prompt={prompt}
                                        sourceOptions={prompts.filter(p => p.id < prompt.id)}
                                        loading={loading[prompt.id]}
                                        onUpdate={updatePrompt}
                                        onDelete={deletePrompt}
                                        onRun={runPrompt}
                                        uploadedImages={uploadedImages}
                                    />
                                ))}
                            </div>
                        </div>

                        <div className="footer">
                            <button onClick={addPrompt} className="btn btn-agency">
                                Add Prompt
                            </button>
                            <button onClick={runAllPrompts} className="btn btn-agency">
                                Run All
                            </button>
                            <input
                                type="file"
                                id="loadAgencyInput"
                                className="hidden"
                                accept=".json"
                                onChange={loadAgency}
                            />
                            <button 
                                onClick={() => document.getElementById('loadAgencyInput').click()} 
                                className="btn btn-agency"
                            >
                                Load Agency
                            </button>
                            <button onClick={exportAgency} className="btn btn-agency">
                                Export Agency
                            </button>
                            <button onClick={exportContent} className="btn btn-agency">
                                Export Content
                            </button>
                        </div>
                    </div>
                </>
            );
        }

        // Initialize React App
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
