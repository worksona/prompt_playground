<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worksona Playground</title>
    
    <!-- Core Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    
    <!-- Document Processing Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    
    <style>
        /* Color Variables */
        :root {
            --bold-orange: #FFA07A;
            --deep-blue: #5A7D9A;
            --light-orange: #FFDAB9;
            --light-blue: #B0E0E6;
            --neutral-gray: #A9A9A9;
            --white: #FFFFFF;
        }

        /* Base styles */
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--light-blue);
            overflow-x: hidden;
            position: relative;
        }

        #voronoi-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .container {
            padding: 2rem;
            display: flex;
            min-height: calc(100vh - 4rem);
            position: relative;
            z-index: 1;
        }

        /* Agency Details styles */
        .agency-details {
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.9);
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 1px 3px rgba(90, 125, 154, 0.2);
            backdrop-filter: blur(5px);
            border: 1px solid var(--light-orange);
        }

        .agency-name-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: none;
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.95);
            font-size: 1.25rem;
            font-weight: 500;
            height: 3rem;
        }

        .agency-description-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.95);
            min-height: 6rem;
        }

        /* Persona styles */
        .persona-tray {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
        }

        .persona-selector-container {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .persona-selector {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: var(--white);
        }

        .add-persona-btn {
            background: var(--deep-blue);
            color: var(--white);
            border: none;
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .persona-card {
            background: var(--light-orange);
            border-radius: 1rem;
            padding: 1rem;
            min-width: 300px;
            max-width: 400px;
            height: fit-content;
            flex-shrink: 0;
            border: 1px solid var(--bold-orange);
        }

        .persona-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .persona-emoji {
            font-size: 2rem;
        }

        .persona-title {
            font-weight: 500;
            color: var(--deep-blue);
        }

        .persona-name {
            font-weight: 500;
            color: var(--deep-blue);
        }

        .direction-selector {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: var(--white);
            margin-bottom: 1rem;
        }

        .persona-textarea {
            width: 100%;
            min-height: 150px;
            padding: '0.75rem 1rem';
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.95);
            margin-bottom: 1rem;
        }

        /* Image Upload styles */
        .image-upload-zone {
            border: 2px dashed var(--deep-blue);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.9);
            margin-bottom: 1rem;
        }

        .image-upload-zone:hover {
            border-color: var(--bold-orange);
            background: rgba(255, 255, 255, 0.95);
        }

        .image-preview {
            max-width: 100%;
            max-height: 300px;
            margin: 1rem 0;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Image Tray styles */
        .image-tray {
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.9);
        }

        .image-tray-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--deep-blue);
        }

        .image-preview-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .image-preview-item {
            position: relative;
            width: 100px;
            height: 100px;
            border-radius: 0.5rem;
            overflow: hidden;
            border: 2px solid transparent;
        }

        .image-preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-preview-item.selected {
            border-color: var(--bold-orange);
        }

        .image-preview-item .delete-button {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--deep-blue);
            font-weight: bold;
        }

        .image-prompt-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 1rem;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .image-preview-container {
            position: relative;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .image-preview-container img {
            max-width: 100%;
            display: block;
        }

        /* Login screen styles */
        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(176, 224, 230, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .login-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--deep-blue);
        }

        .password-input,
        .api-key-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.95);
        }

        /* Fixed left section */
        .fixed-section {
            width: 25%;
            min-width: 300px;
            max-width: 400px;
            flex-shrink: 0;
            padding: 1.5rem;
            border-right: 1px solid var(--deep-blue);
            background: rgba(255, 255, 255, 0.9);
            height: calc(100vh - 4rem - 76px);
            overflow-y: auto;
            position: fixed;
            left: 2rem;
            top: 2rem;
            box-shadow: 2px 0 4px rgba(90, 125, 154, 0.2);
            z-index: 100;
            backdrop-filter: blur(5px);
            border-radius: 1rem;
        }

        /* Content area */
        .content-area {
            flex: 1;
            margin-left: calc(25% + 3rem);
            min-width: 0;
            padding-bottom: 76px;
            padding-left: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        /* Horizontal scroll */
        .horizontal-scroll {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            padding: 1rem 0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: var(--deep-blue) transparent;
        }

        .horizontal-scroll::-webkit-scrollbar {
            height: 8px;
            border-radius: 4px;
        }

        .horizontal-scroll::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 4px;
        }

        .horizontal-scroll::-webkit-scrollbar-thumb {
            background-color: var(--deep-blue);
            border-radius: 4px;
        }

        /* Prompt card styles */
        .prompt-card {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1rem;
            box-shadow: 0 1px 3px rgba(90, 125, 154, 0.2);
            padding: 0.75rem;
            min-width: 300px;
            max-width: 400px;
            height: fit-content;
            flex-shrink: 0;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid var(--light-orange);
        }

        .prompt-card.image-mode {
            border-left: 4px solid var(--bold-orange);
        }

        .source-label {
            color: var(--deep-blue);
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .source-selector {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background-color: var(--white);
            outline: none;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .source-type-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 0.5rem;
        }

        .source-type-button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.5rem;
            background: var(--white);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .source-type-button.active {
            background: var(--deep-blue);
            color: var(--white);
        }

        .prompt-textarea {
            width: 100%;
            min-height: 150px;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.95);
            margin: 0;
            box-sizing: border-box;
            cursor: text;
            transition: border-color 0.2s ease;
        }

        .prompt-textarea:focus {
            border-color: var(--bold-orange);
            box-shadow: 0 0 0 2px rgba(255, 160, 122, 0.2);
        }

        .prompt-textarea::placeholder {
            color: var(--neutral-gray);
            opacity: 0.7;
        }

        .result-container {
            position: relative;
            width: 100%;
        }

        .result-textarea {
            width: 100%;
            min-height: 200px;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
            background: rgba(176, 224, 230, 0.1);
            margin: 0;
            box-sizing: border-box;
        }

        /* Button styles */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background-color: var(--deep-blue);
            color: var(--white);
            width: 100%;
        }

        .btn-success {
            background-color: var(--bold-orange);
            color: var(--white);
            width: 100%;
        }

        .btn-danger {
            background-color: var(--neutral-gray);
            color: var(--white);
            width: 100%;
        }

        .btn-agency {
            background-color: var(--deep-blue);
            color: var(--white);
        }

        /* Footer styles */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.9);
            padding: 1rem;
            box-shadow: 0 -1px 3px rgba(90, 125, 154, 0.2);
            display: flex;
            justify-content: center;
            gap: 1rem;
            z-index: 200;
            backdrop-filter: blur(5px);
            border-radius: 1rem 1rem 0 0;
            border-top: 1px solid var(--light-blue);
        }

        /* Loading spinner */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--white);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Utility styles */
        .hidden {
            display: none;
        }

        .error {
            background-color: rgba(255, 160, 122, 0.2);
            border-left: 4px solid var(--bold-orange);
            padding: 1rem;
            margin: 1rem 0;
            color: #b91c1c;
            border-radius: 0.75rem;
        }

        /* Copy button styles */
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--deep-blue);
            border-radius: 0.5rem;
            padding: 0.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .copy-button svg {
            width: 16px;
            height: 16px;
            stroke: var(--deep-blue);
        }

        .copy-button:hover {
            background: var(--deep-blue);
        }

        .copy-button:hover svg {
            stroke: var(--white);
        }

        .model-selector {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--deep-blue);
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.95);
            outline: none;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <canvas id="voronoi-canvas"></canvas>
    <div id="root"></div>
    <script type="text/babel">
        // Constants
        const OPENAI_MODELS = [
            "gpt-4o",
            "gpt-3.5-turbo-1106",
            "gpt-3.5-turbo",
        ];

        const SUPPORTED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/gif'];
        const MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10MB

        const PERSONAS = [
            {
                id: 'executive',
                name: 'Executive',
                emoji: 'ðŸ‘”',
                description: 'A senior business executive focused on strategic decision-making and high-level business impact.'
            },
            {
                id: 'engineer',
                name: 'Engineer',
                emoji: 'ðŸ‘¨â€ðŸ’»',
                description: 'A technical professional with deep understanding of systems, processes, and technical implementations.'
            },
            {
                id: 'creative',
                name: 'Creative Director',
                emoji: 'ðŸŽ¨',
                description: 'A creative professional focused on design, aesthetics, and brand storytelling.'
            },
            {
                id: 'analyst',
                name: 'Data Analyst',
                emoji: 'ðŸ“Š',
                description: 'An analytical professional focused on data-driven insights and quantitative analysis.'
            },
            {
                id: 'marketer',
                name: 'Marketing Manager',
                emoji: 'ðŸ“¢',
                description: 'A marketing professional focused on audience engagement and campaign effectiveness.'
            }
        ];

        // Voronoi Background Component
        const VoronoiBackground = () => {
            React.useEffect(() => {
                const canvas = document.getElementById('voronoi-canvas');
                const context = canvas.getContext('2d');
                const numPoints = 100;
                const points = [];
                let width = window.innerWidth;
                let height = window.innerHeight;
                let animationFrameId;

                class Point {
                    constructor() {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = (Math.random() - 0.5) * 2;
                    }

                    update() {
                        this.x += this.vx;
                        this.y += this.vy;

                        if (this.x < 0 || this.x > width) this.vx *= -1;
                        if (this.y < 0 || this.y > height) this.vy *= -1;
                    }
                }

                function resizeCanvas() {
                    width = window.innerWidth;
                    height = window.innerHeight;
                    canvas.width = width;
                    canvas.height = height;
                }

                function initPoints() {
                    points.length = 0;
                    for (let i = 0; i < numPoints; i++) {
                        points.push(new Point());
                    }
                }

                function drawVoronoi() {
                    context.clearRect(0, 0, width, height);

                    // Update points
                    points.forEach(point => point.update());

                    // Create Voronoi diagram
                    const delaunay = d3.Delaunay.from(points.map(p => [p.x, p.y]));
                    const voronoi = delaunay.voronoi([0, 0, width, height]);

                    // Draw cells
                    context.beginPath();
                    context.strokeStyle = "rgba(90, 125, 154, 0.2)";
                    voronoi.render(context);
                    context.stroke();
                }

                function animate() {
                    drawVoronoi();
                    animationFrameId = requestAnimationFrame(animate);
                }

                // Initialize
                resizeCanvas();
                initPoints();

                // Event listeners
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    initPoints();
                });

                // Start animation
                animate();

                // Cleanup
                return () => {
                    cancelAnimationFrame(animationFrameId);
                    window.removeEventListener('resize', resizeCanvas);
                };
            }, []);

            return null;
        };

        // File Processing Utility
        const FileProcessor = {
            async readPDFFile(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    let text = '';
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const content = await page.getTextContent();
                        const strings = content.items.map(item => item.str);
                        text += strings.join(' ') + '\n';
                    }
                    
                    return text.trim();
                } catch (error) {
                    console.error('PDF Processing Error:', error);
                    throw new Error(`Failed to process PDF file: ${error.message}`);
                }
            },

            async readDocFile(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const result = await mammoth.extractRawText({ arrayBuffer });
                    return result.value.trim();
                } catch (error) {
                    console.error('DOC Processing Error:', error);
                    throw new Error(`Failed to process DOC/DOCX file: ${error.message}`);
                }
            },

            async readTextFile(file) {
                try {
                    const text = await file.text();
                    return text.trim();
                } catch (error) {
                    console.error('Text File Processing Error:', error);
                    throw new Error(`Failed to read text file: ${error.message}`);
                }
            },

            async processImage(file) {
                if (!file || !SUPPORTED_IMAGE_TYPES.includes(file.type)) {
                    throw new Error('Unsupported image type');
                }

                if (file.size > MAX_IMAGE_SIZE) {
                    throw new Error('Image size too large (max 10MB)');
                }

                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Error reading image'));
                    reader.readAsDataURL(file);
                });
            },

            async processFile(file) {
                if (!file) throw new Error('No file provided');

                const fileType = file.type;
                if (SUPPORTED_IMAGE_TYPES.includes(fileType)) {
                    return await this.processImage(file);
                }

                const extension = file.name.toLowerCase().split('.').pop();
                switch (extension) {
                    case 'pdf':
                        return await this.readPDFFile(file);
                    case 'doc':
                    case 'docx':
                        return await this.readDocFile(file);
                    case 'txt':
                    case 'md':
                        return await this.readTextFile(file);
                    default:
                        throw new Error(`Unsupported file type: ${extension}`);
                }
            }
        };

        // React Components
        const CopyButton = ({ text }) => {
            const [copied, setCopied] = React.useState(false);
            
            const copyToClipboard = async () => {
                try {
                    await navigator.clipboard.writeText(text);
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                } catch (err) {
                    console.error('Failed to copy:', err);
                }
            };

            return (
                <button 
                    onClick={copyToClipboard} 
                    className="copy-button" 
                    title={copied ? "Copied!" : "Copy to clipboard"}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        {copied ? (
                            <path d="M20 6L9 17l-5-5"/>
                        ) : (
                            <>
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                            </>
                        )}
                    </svg>
                </button>
            );
        };

        const ProcessingIndicator = ({ isVisible }) => (
            <div className={`processing-file ${!isVisible ? 'hidden' : ''}`}>
                <h3>Processing File...</h3>
                <p>Please wait while we process your content</p>
            </div>
        );

        const LoginScreen = ({ onLogin }) => {
            const [password, setPassword] = React.useState('');
            const [apiKey, setApiKey] = React.useState('');
            const [error, setError] = React.useState('');

            const handleLogin = () => {
                if (password === 'wowsona' && apiKey) {
                    onLogin(apiKey);
                } else {
                    setError('Incorrect password or missing API key');
                }
            };

            return (
                <div className="login-screen">
                    <div className="login-box">
                        <h2 style={{ marginBottom: '1rem', color: 'var(--deep-blue)' }}>Login Required</h2>
                        <input
                            type="password"
                            placeholder="Enter password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            className="password-input"
                            onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
                        />
                        <input
                            type="text"
                            placeholder="Enter OpenAI API Key"
                            value={apiKey}
                            onChange={(e) => setApiKey(e.target.value)}
                            className="api-key-input"
                            onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
                        />
                        <button 
                            onClick={handleLogin}
                            className="btn btn-primary"
                        >
                            Login
                        </button>
                        {error && <div className="error">{error}</div>}
                    </div>
                </div>
            );
        };
        const PersonaCard = ({ persona, onUpdate, onDelete }) => {
            return (
                <div className="persona-card">
                    <div className="persona-header">
                        <span className="persona-emoji">{persona.emoji}</span>
                        <span className="persona-title">PERSONA CARD</span>
                        <input 
                            type="text" 
                            className="persona-name" 
                            value={persona.name} 
                            onChange={(e) => onUpdate(persona.cardId, { name: e.target.value })}
                            style={{ 
                                border: '1px solid var(--deep-blue)',
                                background: '#f0f8ff',
                                borderRadius: '0.75rem',
                                padding: '0.5rem',
                                fontFamily: 'inherit',
                                fontSize: 'inherit',
                                outline: 'none'
                            }}
                        />
                    </div>
                    
                    <select 
                        value={persona.direction}
                        onChange={(e) => onUpdate(persona.cardId, { direction: e.target.value })}
                        className="direction-selector"
                    >
                        <option value="from">AUTHOR</option>
                        <option value="to">AUDIENCE</option>
                    </select>
                    
                    <textarea
                        value={persona.description}
                        onChange={(e) => onUpdate(persona.cardId, { description: e.target.value })}
                        className="persona-textarea"
                        spellCheck="true"
                        rows="6"
                    />
                    
                    <button 
                        onClick={() => onDelete(persona.cardId)}
                        className="btn btn-danger"
                    >
                        Delete
                    </button>
                </div>
            );
        };

        const PersonaTray = ({ onAddPersona }) => {
            const [selectedPersona, setSelectedPersona] = React.useState('');

            const handleAddPersona = () => {
                if (selectedPersona) {
                    const persona = PERSONAS.find(p => p.id === selectedPersona);
                    onAddPersona({
                        ...persona,
                        cardId: Date.now(),
                        direction: 'from'
                    });
                    setSelectedPersona('');
                }
            };

            return (
                <div className="persona-tray" style={{ marginBottom: '1rem' }}>
                    <div className="persona-selector-container">
                        <select 
                            value={selectedPersona}
                            onChange={(e) => setSelectedPersona(e.target.value)}
                            className="persona-selector"
                        >
                            <option value="">Select Persona...</option>
                            {PERSONAS.map(persona => (
                                <option key={persona.id} value={persona.id}>
                                    {persona.emoji} {persona.name}
                                </option>
                            ))}
                        </select>
                        <button 
                            onClick={handleAddPersona}
                            className="add-persona-btn"
                            disabled={!selectedPersona}
                        >
                            +
                        </button>
                    </div>
                </div>
            );
        };

        const PromptCard = ({ prompt, sourceOptions, loading, onUpdate, onDelete, onRun, uploadedImages }) => {
            const isImageMode = prompt.sourceType === 'image';

            return (
                <div className={`prompt-card ${isImageMode ? 'image-mode' : ''}`}>
                    <div className="source-type-selector">
                        <button 
                            className={`source-type-button ${!isImageMode ? 'active' : ''}`}
                            onClick={() => onUpdate(prompt.id, { sourceType: 'text', selectedImage: null })}
                        >
                            Text
                        </button>
                        <button 
                            className={`source-type-button ${isImageMode ? 'active' : ''}`}
                            onClick={() => onUpdate(prompt.id, { sourceType: 'image' })}
                        >
                            Image
                        </button>
                    </div>

                    {isImageMode ? (
                        <select
                            value={prompt.selectedImage || ''}
                            onChange={(e) => onUpdate(prompt.id, { selectedImage: parseInt(e.target.value) })}
                            className="source-selector"
                        >
                            <option value="">Select an image...</option>
                            {uploadedImages.map(img => (
                                <option key={img.id} value={img.id}>
                                    {img.name || `Image ${img.id}`}
                                </option>
                            ))}
                        </select>
                    ) : (
                        <select 
                            value={prompt.source}
                            onChange={(e) => onUpdate(prompt.id, { source: e.target.value })}
                            className="source-selector"
                        >
                            <option value="SOURCE">SOURCE</option>
                            {sourceOptions.map(option => (
                                <option key={option.id} value={`RESULT${option.id}`}>
                                    RESULT{option.id}
                                </option>
                            ))}
                        </select>
                    )}
                    
                    <textarea
                        value={prompt.text}
                        onChange={(e) => onUpdate(prompt.id, { text: e.target.value })}
                        placeholder={isImageMode ? "Enter your image analysis prompt..." : "Enter your prompt..."}
                        className="prompt-textarea"
                        spellCheck="true"
                        autoComplete="off"
                        rows="6"
                    />
                    
                    <div className="result-label">RESULT{prompt.id}</div>
                    
                    <div className="result-container">
                        <textarea
                            value={prompt.result}
                            onChange={(e) => onUpdate(prompt.id, { result: e.target.value })}
                            placeholder="Results will appear here..."
                            className="result-textarea"
                            readOnly
                            rows="8"
                        />
                        <CopyButton text={prompt.result} />
                    </div>
                    
                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                        <button 
                            onClick={() => onRun(prompt.id)} 
                            className="btn btn-success"
                            disabled={loading || (isImageMode && !prompt.selectedImage)}
                        >
                            {loading ? (
                                <span className="loading-spinner" />
                            ) : (
                                isImageMode ? 'Analyze Image' : 'Run'
                            )}
                        </button>
                        <button 
                            onClick={() => onDelete(prompt.id)}
                            className="btn btn-danger"
                        >
                            Delete
                        </button>
                    </div>
                </div>
            );
        };

        // Main App Component
        function App() {
            const [isLoggedIn, setIsLoggedIn] = React.useState(false);
            const [apiKey, setApiKey] = React.useState('');
            const [model, setModel] = React.useState(OPENAI_MODELS[0]);
            const [sourceContent, setSourceContent] = React.useState('');
            const [uploadedImages, setUploadedImages] = React.useState([]);
            const [agencyName, setAgencyName] = React.useState('');
            const [agencyDescription, setAgencyDescription] = React.useState('');
            const [personaCards, setPersonaCards] = React.useState([]);
            const [prompts, setPrompts] = React.useState([{ 
                id: 1, 
                text: '', 
                result: '',
                source: 'SOURCE',
                sourceType: 'text',
                selectedImage: null
            }]);
            const [loading, setLoading] = React.useState({});
            const [error, setError] = React.useState('');
            const [isProcessingFile, setIsProcessingFile] = React.useState(false);

            // Check if user is logged in
            if (!isLoggedIn) {
                return (
                    <>
                        <VoronoiBackground />
                        <LoginScreen onLogin={(key) => { setApiKey(key); setIsLoggedIn(true); }} />
                    </>
                );
            }

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setIsProcessingFile(true);
                setError('');

                try {
                    const content = await FileProcessor.processFile(file);
                    
                    if (SUPPORTED_IMAGE_TYPES.includes(file.type)) {
                        const imageId = Date.now();
                        setUploadedImages(current => [...current, {
                            id: imageId,
                            url: content,
                            name: file.name
                        }]);
                    } else {
                        setSourceContent(content);
                    }
                } catch (error) {
                    setError('Error processing file: ' + error.message);
                } finally {
                    setIsProcessingFile(false);
                }
            };

            const deleteImage = (imageId) => {
                setUploadedImages(current => current.filter(img => img.id !== imageId));
                setPrompts(current => current.map(prompt => 
                    prompt.selectedImage === imageId 
                        ? {...prompt, selectedImage: null}
                        : prompt
                ));
            };

            const ImageTray = () => (
                <div className="image-tray">
                    <div className="image-tray-title">Uploaded Images</div>
                    <div className="image-preview-list">
                        {uploadedImages.map(image => (
                            <div key={image.id} className="image-preview-item">
                                <img src={image.url} alt={image.name} />
                                <button 
                                    className="delete-button"
                                    onClick={() => deleteImage(image.id)}
                                >
                                    Ã—
                                </button>
                            </div>
                        ))}
                    </div>
                </div>
            );

            const addPersonaCard = (persona) => {
                setPersonaCards([...personaCards, persona]);
            };

            const updatePersonaCard = (id, changes) => {
                setPersonaCards(personaCards.map(p => 
                    p.cardId === id ? {...p, ...changes} : p
                ));
            };

            const deletePersonaCard = (id) => {
                setPersonaCards(personaCards.filter(p => p.cardId !== id));
            };

            const addPrompt = () => {
                const newPrompt = {
                    id: Date.now(),
                    text: '',
                    result: '',
                    source: 'SOURCE',
                    sourceType: 'text',
                    selectedImage: null
                };
                setPrompts([...prompts, newPrompt]);
            };

            const deletePrompt = (id) => {
                setPrompts(prompts.filter(p => p.id !== id));
            };

            const updatePrompt = (id, changes) => {
                setPrompts(prompts.map(p => 
                    p.id === id ? {...p, ...changes} : p
                ));
            };

            const getPromptSource = (promptId) => {
                const prompt = prompts.find(p => p.id === promptId);
                if (!prompt || prompt.source === 'SOURCE') return sourceContent;
                
                const sourcePromptId = parseInt(prompt.source.replace('RESULT', ''));
                const sourcePrompt = prompts.find(p => p.id === sourcePromptId);
                return sourcePrompt ? sourcePrompt.result : '';
            };

            const getPersonaContext = () => {
                const fromPersonas = personaCards.filter(p => p.direction === 'from');
                const toPersonas = personaCards.filter(p => p.direction === 'to');
                
                let context = '';
                
                if (fromPersonas.length > 0) {
                    context += `\nRespond FROM the perspective of: ${fromPersonas.map(p => 
                        `${p.name} (${p.description})`).join(', ')}`;
                }
                
                if (toPersonas.length > 0) {
                    context += `\nTarget your response TO: ${toPersonas.map(p => 
                        `${p.name} (${p.description})`).join(', ')}`;
                }
                
                return context;
            };

            const runPrompt = async (id) => {
                setLoading(prev => ({ ...prev, [id]: true }));
                setError('');

                try {
                    const prompt = prompts.find(p => p.id === id);
                    let requestBody;

                    if (prompt.sourceType === 'image') {
                        const selectedImage = uploadedImages.find(img => img.id === prompt.selectedImage);
                        if (!selectedImage) throw new Error('No image selected');

                        requestBody = {
                            model: model,
                            messages: [
                                {
                                    role: "user",
                                    content: [
                                        {
                                            type: "text",
                                            text: `${getPersonaContext()}\n${prompt.text}`
                                        },
                                        {
                                            type: "image_url",
                                            image_url: {
                                                url: selectedImage.url
                                            }
                                        }
                                    ]
                                }
                            ],
                            max_tokens: 500
                        };
                    } else {
                        const sourceText = getPromptSource(id);
                        const personaContext = getPersonaContext();
                        requestBody = {
                            model: model,
                            messages: [
                                { 
                                    role: "system", 
                                    content: `Context:\n${sourceText}${personaContext}`
                                },
                                { 
                                    role: "user", 
                                    content: prompt.text 
                                }
                            ]
                        };
                    }

                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    const data = await response.json();
                    
                    if (data.error) {
                        if (data.error.code === 'model_not_found' || data.error.message.includes('deprecated')) {
                            throw new Error('This model has been deprecated. Please select a different model from the dropdown.');
                        }
                        throw new Error(data.error.message);
                    }

                    const result = data.choices[0].message.content;
                    updatePrompt(id, { result });

                } catch (err) {
                    setError(err.message || 'Error running prompt');
                } finally {
                    setLoading(prev => ({ ...prev, [id]: false }));
                }
            };

            const runAllPrompts = async () => {
                for (const prompt of prompts) {
                    await runPrompt(prompt.id);
                }
            };

            const exportAgency = async () => {
                try {
                    const exportData = {
                        agencyName,
                        agencyDescription,
                        sourceContent,
                        uploadedImages,
                        personaCards,
                        prompts: prompts.map(({ id, text, result, source, sourceType, selectedImage }) => ({
                            id,
                            text,
                            result,
                            source,
                            sourceType,
                            selectedImage
                        })),
                        settings: { model }
                    };
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                        type: 'application/json' 
                    });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `agency-export-${Date.now()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    setError('Error exporting agency: ' + error.message);
                }
            };

            const exportContent = () => {
                try {
                    const content = prompts.map(prompt => {
                        let promptContent = `PROMPT ${prompt.id}:\n${prompt.text}\n\n`;
                        if (prompt.sourceType === 'image') {
                            promptContent += `[Image Analysis]\n`;
                        }
                        promptContent += `RESULT ${prompt.id}:\n${prompt.result}\n\n---\n\n`;
                        return promptContent;
                    }).join('');
                    
                    const blob = new Blob([content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `agency-content-${Date.now()}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    setError('Error exporting content: ' + error.message);
                }
            };

            const loadAgency = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (!data.prompts || !data.settings) {
                            throw new Error('Invalid agency file structure');
                        }

                        setSourceContent(data.sourceContent || '');
                        setPrompts(data.prompts);
                        setModel(data.settings.model || OPENAI_MODELS[0]);
                        setAgencyName(data.agencyName || '');
                        setAgencyDescription(data.agencyDescription || '');
                        setUploadedImages(data.uploadedImages || []);
                        setPersonaCards(data.personaCards || []);
                    } catch (error) {
                        setError('Error loading agency: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };

            return (
                <>
                    <VoronoiBackground />
                    <div className="container">
                        <ProcessingIndicator isVisible={isProcessingFile} />
                        
                        <div className="fixed-section">
                            <input
                                type="file"
                                id="fileInput"
                                className="hidden"
                                accept=".pdf,.doc,.docx,.txt,.md,image/*"
                                onChange={handleFileUpload}
                            />
                            <button 
                                onClick={() => document.getElementById('fileInput').click()}
                                className="btn btn-primary"
                                style={{ marginBottom: '1rem' }}
                            >
                                Upload File or Image
                            </button>

                            <textarea
                                value={sourceContent}
                                onChange={(e) => setSourceContent(e.target.value)}
                                placeholder="Enter or upload source content..."
                                style={{ 
                                    display: 'block',
                                    width: '80%',
                                    minHeight: '200px',
                                    margin: '1rem auto',
                                    padding: '0.75rem',
                                    borderRadius: '0.75rem',
                                    border: '1px solid var(--deep-blue)',
                                    resize: 'vertical'
                                }}
                            />

                            <ImageTray />
                            <PersonaTray onAddPersona={addPersonaCard} />

                            <div className="model-selector-wrapper">
                                <select 
                                    value={model}
                                    onChange={(e) => setModel(e.target.value)}
                                    className="model-selector"
                                >
                                    {OPENAI_MODELS.map(model => (
                                        <option key={model} value={model}>{model}</option>
                                    ))}
                                </select>
                            </div>

                            {error && <div className="error">{error}</div>}
                        </div>

                        <div className="content-area">
                            <div className="agency-details">
                                <textarea
                                    value={agencyName}
                                    onChange={(e) => setAgencyName(e.target.value)}
                                    placeholder="Enter Agency Name..."
                                    className="agency-name-textarea"
                                    style={{ paddingRight: '1rem' }}
                                />
                                <textarea
                                    value={agencyDescription}
                                    onChange={(e) => setAgencyDescription(e.target.value)}
                                    placeholder="Enter Agency Description..."
                                    className="agency-description-textarea"
                                    style={{ paddingRight: '1rem' }}
                                />
                            </div>
                            
                            <div className="horizontal-scroll">
                                {personaCards.map(persona => (
                                    <PersonaCard
                                        key={persona.cardId}
                                        persona={persona}
                                        onUpdate={updatePersonaCard}
                                        onDelete={deletePersonaCard}
                                    />
                                ))}
                                {prompts.map(prompt => (
                                    <PromptCard
                                        key={prompt.id}
                                        prompt={prompt}
                                        sourceOptions={prompts.filter(p => p.id < prompt.id)}
                                        loading={loading[prompt.id]}
                                        onUpdate={updatePrompt}
                                        onDelete={deletePrompt}
                                        onRun={runPrompt}
                                        uploadedImages={uploadedImages}
                                    />
                                ))}
                            </div>
                        </div>

                        <div className="footer">
                            <button onClick={addPrompt} className="btn btn-agency">
                                Add Prompt
                            </button>
                            <button onClick={runAllPrompts} className="btn btn-agency">
                                Run All
                            </button>
                            <input
                                type="file"
                                id="loadAgencyInput"
                                className="hidden"
                                accept=".json"
                                onChange={loadAgency}
                            />
                            <button 
                                onClick={() => document.getElementById('loadAgencyInput').click()} 
                                className="btn btn-agency"
                            >
                                Load Agency
                            </button>
                            <button onClick={exportAgency} className="btn btn-agency">
                                Export Agency
                            </button>
                            <button onClick={exportContent} className="btn btn-agency">
                                Export Content
                            </button>
                        </div>
                    </div>
                </>
            );
        }

        // Initialize React App
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
